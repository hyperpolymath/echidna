// SPDX-FileCopyrightText: 2026 ECHIDNA Project Team
// SPDX-License-Identifier: PMPL-1.0-or-later

//! SPASS backend
//!
//! SPASS (System for Proving Associative Sets with Selections) is a
//! first-order theorem prover with a focus on sorted logic.
//!
//! Features:
//! - First-order logic with equality and sorts
//! - Native SPASS format (DFG format)
//! - Superposition calculus
//! - Sort handling for typed first-order logic

#![allow(dead_code)]

use async_trait::async_trait;
use anyhow::{Context, Result};
use std::path::PathBuf;
use std::process::Stdio;
use tokio::io::AsyncWriteExt;
use tokio::process::Command;

use super::{ProverBackend, ProverConfig, ProverKind};
use crate::core::{Goal, Hypothesis, ProofState, Tactic, TacticResult, Term};

/// SPASS theorem prover backend
pub struct SPASSBackend {
    config: ProverConfig,
}

impl SPASSBackend {
    pub fn new(config: ProverConfig) -> Self {
        SPASSBackend { config }
    }

    /// Convert proof state to SPASS DFG format
    fn to_dfg(&self, state: &ProofState) -> Result<String> {
        let mut dfg = String::new();

        dfg.push_str("begin_problem(Generated).\n\n");
        dfg.push_str("list_of_descriptions.\n");
        dfg.push_str("name({*Generated by ECHIDNA*}).\n");
        dfg.push_str("author({*ECHIDNA*}).\n");
        dfg.push_str("status(unknown).\n");
        dfg.push_str("description({*Auto-generated problem*}).\n");
        dfg.push_str("end_of_list.\n\n");

        // Axioms
        dfg.push_str("list_of_formulae(axioms).\n");
        for (i, axiom) in state.context.axioms.iter().enumerate() {
            dfg.push_str(&format!("formula({}, {}).\n", axiom, i));
        }
        dfg.push_str("end_of_list.\n\n");

        // Conjecture
        if let Some(goal) = state.goals.first() {
            dfg.push_str("list_of_formulae(conjectures).\n");
            dfg.push_str(&format!("formula({}).\n", goal.target));
            dfg.push_str("end_of_list.\n\n");
        }

        dfg.push_str("end_problem.\n");

        Ok(dfg)
    }

    /// Parse SPASS output
    fn parse_result(&self, output: &str) -> Result<bool> {
        if output.contains("Proof found")
            || output.contains("proof found")
            || output.contains("SPASS beiseite: Proof")
        {
            Ok(true)
        } else if output.contains("Completion found") {
            Ok(false)
        } else {
            Err(anyhow::anyhow!(
                "SPASS inconclusive: {}",
                output.lines().take(10).collect::<Vec<_>>().join("\n")
            ))
        }
    }
}

#[async_trait]
impl ProverBackend for SPASSBackend {
    fn kind(&self) -> ProverKind {
        ProverKind::SPASS
    }

    async fn version(&self) -> Result<String> {
        let output = Command::new(&self.config.executable)
            .output()
            .await
            .context("Failed to run SPASS")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            if line.contains("SPASS") && line.contains("Version") {
                return Ok(line.trim().to_string());
            }
        }
        Ok("unknown".to_string())
    }

    async fn parse_file(&self, path: PathBuf) -> Result<ProofState> {
        let content = tokio::fs::read_to_string(path)
            .await
            .context("Failed to read proof file")?;
        self.parse_string(&content).await
    }

    async fn parse_string(&self, content: &str) -> Result<ProofState> {
        let mut state = ProofState::default();

        let mut in_axioms = false;
        let mut in_conjectures = false;

        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("list_of_formulae(axioms)") {
                in_axioms = true;
                in_conjectures = false;
            } else if line.starts_with("list_of_formulae(conjectures)") {
                in_conjectures = true;
                in_axioms = false;
            } else if line.starts_with("end_of_list") {
                in_axioms = false;
                in_conjectures = false;
            } else if line.starts_with("formula(") {
                if let Some(formula) = line.strip_prefix("formula(").and_then(|s| s.strip_suffix(").")) {
                    if in_axioms {
                        state.context.axioms.push(formula.to_string());
                    } else if in_conjectures {
                        state.goals.push(Goal {
                            id: format!("goal_{}", state.goals.len()),
                            target: Term::Const(formula.to_string()),
                            hypotheses: vec![],
                        });
                    }
                }
            }
        }

        Ok(state)
    }

    async fn apply_tactic(&self, _state: &ProofState, _tactic: &Tactic) -> Result<TacticResult> {
        Err(anyhow::anyhow!(
            "SPASS is fully automated - interactive tactics not supported"
        ))
    }

    async fn verify_proof(&self, state: &ProofState) -> Result<bool> {
        let dfg_code = self.to_dfg(state)?;

        let mut child = Command::new(&self.config.executable)
            .arg("-TimeLimit").arg(format!("{}", self.config.timeout))
            .arg("-PGiven=0")
            .arg("-PProblem=0")
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .context("Failed to spawn SPASS process")?;

        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(dfg_code.as_bytes()).await?;
            stdin.flush().await?;
            drop(stdin);
        }

        let output = tokio::time::timeout(
            tokio::time::Duration::from_secs(self.config.timeout + 5),
            child.wait_with_output(),
        )
        .await
        .context("SPASS timed out")??;

        let stdout = String::from_utf8_lossy(&output.stdout);
        self.parse_result(&stdout)
    }

    async fn export(&self, state: &ProofState) -> Result<String> {
        self.to_dfg(state)
    }

    async fn suggest_tactics(&self, _state: &ProofState, _limit: usize) -> Result<Vec<Tactic>> {
        Ok(vec![])
    }

    async fn search_theorems(&self, _pattern: &str) -> Result<Vec<String>> {
        Ok(vec![])
    }

    fn config(&self) -> &ProverConfig {
        &self.config
    }

    fn set_config(&mut self, config: ProverConfig) {
        self.config = config;
    }
}
