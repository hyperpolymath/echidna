// SPDX-FileCopyrightText: 2026 ECHIDNA Project Team
// SPDX-License-Identifier: PMPL-1.0-or-later

//! Alt-Ergo backend
//!
//! Alt-Ergo is an SMT solver with native support for polymorphic first-order logic.
//! Designed for program verification (Why3, Frama-C integration).
//!
//! Features:
//! - Polymorphic first-order logic
//! - Built-in theories (arithmetic, arrays, records, ADTs)
//! - Native Alt-Ergo format or SMT-LIB2
//! - Excellent integration with Why3

#![allow(dead_code)]

use async_trait::async_trait;
use anyhow::{Context, Result};
use std::path::PathBuf;
use std::process::Stdio;
use tokio::io::AsyncWriteExt;
use tokio::process::Command;

use super::{ProverBackend, ProverConfig, ProverKind};
use crate::core::{Goal, Hypothesis, ProofState, Tactic, TacticResult, Term};

/// Alt-Ergo theorem prover backend
pub struct AltErgoBackend {
    config: ProverConfig,
}

impl AltErgoBackend {
    pub fn new(config: ProverConfig) -> Self {
        AltErgoBackend { config }
    }

    /// Convert proof state to Alt-Ergo native format
    fn to_altergo(&self, state: &ProofState) -> Result<String> {
        let mut ae = String::new();

        ae.push_str("(* Generated by ECHIDNA *)\n\n");

        // Axioms
        for (i, axiom) in state.context.axioms.iter().enumerate() {
            ae.push_str(&format!("axiom axiom_{} : {};\n", i, axiom));
        }

        ae.push_str("\n");

        // Goal
        if let Some(goal) = state.goals.first() {
            ae.push_str(&format!("goal conjecture : {};\n", goal.target));
        }

        Ok(ae)
    }

    /// Convert to SMT-LIB2 format (alternative)
    fn to_smtlib2(&self, state: &ProofState) -> Result<String> {
        let mut smt = String::new();

        smt.push_str("(set-logic ALL)\n");

        // Axioms
        for axiom in &state.context.axioms {
            smt.push_str(&format!("(assert {})\n", axiom));
        }

        // Goal (negated for refutation)
        if let Some(goal) = state.goals.first() {
            smt.push_str(&format!("(assert (not {}))\n", goal.target));
        }

        smt.push_str("(check-sat)\n");

        Ok(smt)
    }

    /// Parse Alt-Ergo output
    fn parse_result(&self, output: &str) -> Result<bool> {
        if output.contains("Valid")
            || output.contains("unsat")
        {
            Ok(true)
        } else if output.contains("Invalid")
            || output.contains("sat")
        {
            Ok(false)
        } else {
            Err(anyhow::anyhow!(
                "Alt-Ergo inconclusive: {}",
                output.lines().take(10).collect::<Vec<_>>().join("\n")
            ))
        }
    }
}

#[async_trait]
impl ProverBackend for AltErgoBackend {
    fn kind(&self) -> ProverKind {
        ProverKind::AltErgo
    }

    async fn version(&self) -> Result<String> {
        let output = Command::new(&self.config.executable)
            .arg("--version")
            .output()
            .await
            .context("Failed to run alt-ergo --version")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        Ok(stdout.lines().next().unwrap_or("unknown").trim().to_string())
    }

    async fn parse_file(&self, path: PathBuf) -> Result<ProofState> {
        let content = tokio::fs::read_to_string(path)
            .await
            .context("Failed to read proof file")?;
        self.parse_string(&content).await
    }

    async fn parse_string(&self, content: &str) -> Result<ProofState> {
        let mut state = ProofState::default();

        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with("(*") {
                continue;
            }

            if line.starts_with("axiom ") {
                if let Some(formula) = line.split(':').nth(1) {
                    let formula = formula.trim_end_matches(';').trim();
                    state.context.axioms.push(formula.to_string());
                }
            } else if line.starts_with("goal ") {
                if let Some(formula) = line.split(':').nth(1) {
                    let formula = formula.trim_end_matches(';').trim();
                    state.goals.push(Goal {
                        id: format!("goal_{}", state.goals.len()),
                        target: Term::Const(formula.to_string()),
                        hypotheses: vec![],
                    });
                }
            }
        }

        Ok(state)
    }

    async fn apply_tactic(&self, _state: &ProofState, _tactic: &Tactic) -> Result<TacticResult> {
        Err(anyhow::anyhow!(
            "Alt-Ergo is fully automated - interactive tactics not supported"
        ))
    }

    async fn verify_proof(&self, state: &ProofState) -> Result<bool> {
        let ae_code = self.to_altergo(state)?;

        // Write to temp file since Alt-Ergo prefers file input
        let tmp_dir = std::env::temp_dir();
        let tmp_file = tmp_dir.join("echidna_altergo_input.ae");
        tokio::fs::write(&tmp_file, ae_code.as_bytes())
            .await
            .context("Failed to write temp file")?;

        let output = tokio::time::timeout(
            tokio::time::Duration::from_secs(self.config.timeout + 5),
            Command::new(&self.config.executable)
                .arg(&tmp_file)
                .arg("--timelimit").arg(format!("{}", self.config.timeout))
                .output(),
        )
        .await
        .context("Alt-Ergo timed out")??;

        // Clean up temp file
        let _ = tokio::fs::remove_file(&tmp_file).await;

        let stdout = String::from_utf8_lossy(&output.stdout);
        self.parse_result(&stdout)
    }

    async fn export(&self, state: &ProofState) -> Result<String> {
        self.to_altergo(state)
    }

    async fn suggest_tactics(&self, _state: &ProofState, _limit: usize) -> Result<Vec<Tactic>> {
        Ok(vec![])
    }

    async fn search_theorems(&self, _pattern: &str) -> Result<Vec<String>> {
        Ok(vec![])
    }

    fn config(&self) -> &ProverConfig {
        &self.config
    }

    fn set_config(&mut self, config: ProverConfig) {
        self.config = config;
    }
}
